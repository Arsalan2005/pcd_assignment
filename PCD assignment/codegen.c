#include "codegen.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static CodeGenerator codegen;
static char assembly_code[10000];

void init_codegen() {
    codegen.instr_count = 0;
    codegen.temp_count = 0;
    codegen.label_count = 0;
    memset(assembly_code, 0, sizeof(assembly_code));
}

char* new_temp() {
    static char temp[20];
    sprintf(temp, "t%d", codegen.temp_count++);
    return temp;
}

char* new_label() {
    static char label[20];
    sprintf(label, "L%d", codegen.label_count++);
    return label;
}

void emit(const char* op, const char* arg1, const char* arg2, const char* result) {
    if (codegen.instr_count >= MAX_CODE_LINES) return;
    
    TAC* instr = &codegen.instructions[codegen.instr_count++];
    strncpy(instr->op, op, sizeof(instr->op) - 1);
    instr->op[sizeof(instr->op) - 1] = '\0';
    
    if (arg1) {
        strncpy(instr->arg1, arg1, sizeof(instr->arg1) - 1);
        instr->arg1[sizeof(instr->arg1) - 1] = '\0';
    } else instr->arg1[0] = '\0';
    
    if (arg2) {
        strncpy(instr->arg2, arg2, sizeof(instr->arg2) - 1);
        instr->arg2[sizeof(instr->arg2) - 1] = '\0';
    } else instr->arg2[0] = '\0';
    
    if (result) {
        strncpy(instr->result, result, sizeof(instr->result) - 1);
        instr->result[sizeof(instr->result) - 1] = '\0';
    } else instr->result[0] = '\0';
}

void generate_code_from_tokens() {
    // This is a simplified code generator for arithmetic expressions
    // It generates three-address code
    
    init_codegen();
    
    // Example: For "a + b * c", generate:
    // t1 = b * c
    // t2 = a + t1
    
    emit("=", "a", "", "t0");
    emit("=", "b", "", "t1");
    emit("=", "c", "", "t2");
    emit("*", "t1", "t2", "t3");
    emit("+", "t0", "t3", "t4");
}

char* generate_assembly() {
    assembly_code[0] = '\0';
    char buffer[500];
    
    strcat(assembly_code, "; Assembly Code Generated by Compiler\n");
    strcat(assembly_code, "; Target: x86-64 Architecture\n");
    strcat(assembly_code, "\n");
    strcat(assembly_code, "section .data\n");
    
    // Add variable declarations
    for (int i = 0; i < codegen.temp_count; i++) {
        sprintf(buffer, "    t%d: dq 0\n", i);
        strcat(assembly_code, buffer);
    }
    
    strcat(assembly_code, "\nsection .text\n");
    strcat(assembly_code, "    global _start\n\n");
    strcat(assembly_code, "_start:\n");
    
    // Generate assembly from TAC
    for (int i = 0; i < codegen.instr_count; i++) {
        TAC* instr = &codegen.instructions[i];
        
        if (strcmp(instr->op, "=") == 0) {
            sprintf(buffer, "    mov rax, [%s]      ; %s = %s\n", 
                    instr->arg1, instr->result, instr->arg1);
            strcat(assembly_code, buffer);
            sprintf(buffer, "    mov [%s], rax\n", instr->result);
            strcat(assembly_code, buffer);
        }
        else if (strcmp(instr->op, "+") == 0) {
            sprintf(buffer, "    mov rax, [%s]      ; %s = %s + %s\n", 
                    instr->arg1, instr->result, instr->arg1, instr->arg2);
            strcat(assembly_code, buffer);
            sprintf(buffer, "    add rax, [%s]\n", instr->arg2);
            strcat(assembly_code, buffer);
            sprintf(buffer, "    mov [%s], rax\n", instr->result);
            strcat(assembly_code, buffer);
        }
        else if (strcmp(instr->op, "-") == 0) {
            sprintf(buffer, "    mov rax, [%s]      ; %s = %s - %s\n", 
                    instr->arg1, instr->result, instr->arg1, instr->arg2);
            strcat(assembly_code, buffer);
            sprintf(buffer, "    sub rax, [%s]\n", instr->arg2);
            strcat(assembly_code, buffer);
            sprintf(buffer, "    mov [%s], rax\n", instr->result);
            strcat(assembly_code, buffer);
        }
        else if (strcmp(instr->op, "*") == 0) {
            sprintf(buffer, "    mov rax, [%s]      ; %s = %s * %s\n", 
                    instr->arg1, instr->result, instr->arg1, instr->arg2);
            strcat(assembly_code, buffer);
            sprintf(buffer, "    imul rax, [%s]\n", instr->arg2);
            strcat(assembly_code, buffer);
            sprintf(buffer, "    mov [%s], rax\n", instr->result);
            strcat(assembly_code, buffer);
        }
        else if (strcmp(instr->op, "/") == 0) {
            sprintf(buffer, "    mov rax, [%s]      ; %s = %s / %s\n", 
                    instr->arg1, instr->result, instr->arg1, instr->arg2);
            strcat(assembly_code, buffer);
            sprintf(buffer, "    xor rdx, rdx\n");
            strcat(assembly_code, buffer);
            sprintf(buffer, "    idiv qword [%s]\n", instr->arg2);
            strcat(assembly_code, buffer);
            sprintf(buffer, "    mov [%s], rax\n", instr->result);
            strcat(assembly_code, buffer);
        }
        
        strcat(assembly_code, "\n");
    }
    
    // Exit system call
    strcat(assembly_code, "    ; Exit program\n");
    strcat(assembly_code, "    mov rax, 60        ; sys_exit\n");
    strcat(assembly_code, "    xor rdi, rdi       ; exit code 0\n");
    strcat(assembly_code, "    syscall\n");
    
    return assembly_code;
}

void print_tac() {
    printf("\n=== THREE-ADDRESS CODE ===\n");
    for (int i = 0; i < codegen.instr_count; i++) {
        TAC* instr = &codegen.instructions[i];
        printf("%d: ", i);
        
        if (strcmp(instr->op, "=") == 0) {
            printf("%s = %s\n", instr->result, instr->arg1);
        } else {
            printf("%s = %s %s %s\n", instr->result, instr->arg1, instr->op, instr->arg2);
        }
    }
}
